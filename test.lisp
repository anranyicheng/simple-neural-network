(require :sb-sprof)
(ql:quickload '("simple-neural-network" "chipz") :silent t)

(defpackage :simple-neural-network-tests
  (:use :cl :simple-neural-network))

(in-package :simple-neural-network-tests)

(defun load-mnist (type)
  (destructuring-bind (n-images images-path labels-path)
      (if (eql type :train)
          '(60000
            "mnist/train-images-idx3-ubyte.gz"
            "mnist/train-labels-idx1-ubyte.gz")
          '(10000
            "mnist/t10k-images-idx3-ubyte.gz"
            "mnist/t10k-labels-idx1-ubyte.gz"))
    (let ((images (with-open-file (f images-path :element-type '(unsigned-byte 8))
                    (let ((images-data (chipz:decompress nil 'chipz:gzip f)))
                      (loop for i from 0 below n-images
                            collect (coerce (loop with offset = (+ 16 (* i 28 28))
                                                  for j from 0 below (* 28 28)
                                                  collect (aref images-data (+ offset j)))
                                            'vector)))))
          (labels (with-open-file (f labels-path :element-type '(unsigned-byte 8))
                    (let ((labels-data (chipz:decompress nil 'chipz:gzip f)))
                      (loop for i from 0 below n-images
                            collect (let ((v (aref labels-data (+ 8 i)))
                                          (a (make-array 10 :initial-element 0)))
                                      (setf (aref a v) 1)
                                      a))))))
      (values images labels))))

(defun test-mnist ()
  (multiple-value-bind (inputs targets) (load-mnist :test)
    (setf inputs (mapcar (lambda (input)
                           (map 'vector (lambda (x) (/ x 255.0d0)) input))
                         inputs))
    (let ((nn (create-neural-network (* 28 28) 10 128)))
      (dotimes (i 10)
        (format t "~&Iteration ~d~%" i)
        ;; (if (zerop i)
        ;;     (sb-sprof:with-profiling (:mode :cpu :reset t :report :flat)
        ;;       (train nn inputs targets))
        ;;    (train nn inputs targets))
        (train nn inputs targets)
        (format t "~f~%" (accuracy nn inputs targets)))
      ;; (mapc (lambda (input target)
      ;;         (let ((output (simple-neural-network:predict nn input)))
      ;;           (format t "~&output=~a target=~a~%" output target)))
      ;;       (subseq inputs 0 5)
      ;;       (subseq targets 0 5))
      t)))

(defun test ()
  (let ((nn (create-neural-network 2 2 2))
        (inputs '(#(1.0d0 1.0d0) #(2.0d0 2.0d0) #(3.0d0 3.0d0) #(4.0d0 4.0d0)
                  #(1.0d0 -1.0d0) #(2.0d0 -2.0d0) #(3.0d0 -3.0d0) #(4.0d0 -4.0d0)
                  #(-1.0d0 1.0d0) #(-2.0d0 2.0d0) #(-3.0d0 3.0d0) #(-4.0d0 4.0d0)
                  #(-1.0d0 -1.0d0) #(-2.0d0 -2.0d0) #(-3.0d0 -3.0d0) #(-4.0d0 -4.0d0)))
        (targets '(#(1.0d0 0.0d0) #(1.0d0 0.0d0) #(1.0d0 0.0d0) #(1.0d0 0.0d0)
                   #(1.0d0 0.0d0) #(1.0d0 0.0d0) #(1.0d0 0.0d0) #(1.0d0 0.0d0)
                   #(0.0d0 1.0d0) #(0.0d0 1.0d0) #(0.0d0 1.0d0) #(0.0d0 1.0d0)
                   #(0.0d0 1.0d0) #(0.0d0 1.0d0) #(0.0d0 1.0d0) #(0.0d0 1.0d0))))
    (setf inputs (mapcar (lambda (input)
                           (map 'vector (lambda (x) (/ x 4.0d0)) input))
                         inputs))
    (dotimes (i 1000)
      (train nn inputs targets))
    (mapc (lambda (input target)
            (let ((output (simple-neural-network:predict nn input)))
              (format t "output=~a target=~a~%" output target)))
          inputs targets)
    (print (accuracy nn inputs targets))))
